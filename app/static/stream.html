<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dual Camera Stream</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      color: white;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0;
      flex: 1;
    }

    .camera {
      flex: 0 1 auto;           /* 크기 자동 */
      max-width: 45%;           /* 두 개가 합쳐서 중앙 차지 */
      max-height: 90%;          /* 화면 꽉 차지 않게 */
      object-fit: contain;
      border-radius: 8px;
      transition: all 0.3s ease;
    }

    .vertical {
      flex-direction: column;
    }

    .controls {
      padding: 10px;
      background: #111;
      color: white;
      display: flex;
      gap: 20px;
      align-items: center;
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.5s ease, transform 0.5s ease;
    }

    .controls.hidden {
      opacity: 0;
      transform: translateY(-100%);
      pointer-events: none;
    }

    input[type="range"] {
      width: 200px;
    }
  </style>
</head>
<body>
  <div class="controls">
    <label>간격: <span id="gapValue">0</span></label>
    <input type="range" id="gapSlider" min="0" max="200" step="1" />
    <label><input type="checkbox" id="distortedToggle" /> 좌우 반전</label>
    <label><input type="checkbox" id="orderToggle" /> 순서 변경</label>
    <button id="saveBtn">저장</button>
  </div>

  <div id="app" class="container">
    <img id="cam0" alt="Camera 0" class="camera" />
    <img id="cam1" alt="Camera 1" class="camera" />
  </div>

  <script>
    const cam0 = document.getElementById("cam0");
    const cam1 = document.getElementById("cam1");
    const gapSlider = document.getElementById("gapSlider");
    const gapValue = document.getElementById("gapValue");
    const distortedToggle = document.getElementById("distortedToggle");
    const saveBtn = document.getElementById("saveBtn");
    const swapBtn = document.getElementById("swapBtn");
    const app = document.getElementById("app");
    const controls = document.querySelector(".controls");

    let gap = 0;
    let distorted = false;
    let cameraOrder = "01";

    const applyConfig = () => {
      const halfGap = gap / 2;

      if (cameraOrder === "01") {
        cam0.style.marginRight = `${halfGap}px`;
        cam0.style.marginLeft = "0";
        cam1.style.marginLeft = `${halfGap}px`;
        cam1.style.marginRight = "0";
      } else {
        cam1.style.marginRight = `${halfGap}px`;
        cam1.style.marginLeft = "0";
        cam0.style.marginLeft = `${halfGap}px`;
        cam0.style.marginRight = "0";
      }

      cam0.style.transform = distorted ? "scaleX(-1)" : "none";
      cam1.style.transform = distorted ? "scaleX(-1)" : "none";

      const isLandscape = window.innerWidth > window.innerHeight;
      app.classList.toggle("vertical", !isLandscape);
    };

    window.addEventListener("resize", applyConfig);

    const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
    const ws0 = new WebSocket(`${wsScheme}://${location.host}/ws/stream/0`);
    const ws1 = new WebSocket(`${wsScheme}://${location.host}/ws/stream/1`);

    ws0.binaryType = "arraybuffer";
    ws1.binaryType = "arraybuffer";

    ws0.onmessage = (event) => {
      const blob = new Blob([event.data], { type: "image/jpeg" });
      const url = URL.createObjectURL(blob);
      cam0.src = url;
      cam0.onload = () => URL.revokeObjectURL(url);
    };

    ws1.onmessage = (event) => {
      const blob = new Blob([event.data], { type: "image/jpeg" });
      const url = URL.createObjectURL(blob);
      cam1.src = url;
      cam1.onload = () => URL.revokeObjectURL(url);
    };

    document.body.addEventListener("click", () => {
      const elem = document.documentElement;
      if (elem.requestFullscreen) elem.requestFullscreen();
      else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
      else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
    }, { once: true });

    // 초기 설정 불러오기
    async function fetchAndApplyConfig() {
      try {
        const res = await fetch("/config");
        const config = await res.json();

        gap = Number(config.gap) || 0;
        distorted = config.distorted === true;
        cameraOrder = config.order || "01";

        gapSlider.value = gap;
        gapValue.textContent = gap;
        distortedToggle.checked = distorted;
        orderToggle.checked = (cameraOrder === "10");

        // 순서 적용
        if (cameraOrder === "10") {
          app.insertBefore(cam1, cam0);
        } else {
          app.insertBefore(cam0, cam1);
        }

        applyConfig();
      } catch (e) {
        console.error("Failed to fetch /config", e);
      }
    }

    // 저장 버튼 클릭 → 서버에 POST 요청
    saveBtn.addEventListener("click", async () => {
      const formData = new FormData();
      formData.append("gap", gapSlider.value);
      formData.append("distorted", distortedToggle.checked);
      formData.append("order", cameraOrder);

      try {
        const res = await fetch("/config", {
          method: "POST",
          body: formData,
        });
        const result = await res.json();
        console.log("Saved:", result);

        gap = Number(gapSlider.value);
        distorted = distortedToggle.checked;
        gapValue.textContent = gap;

        applyConfig();
      } catch (e) {
        console.error("Failed to save config", e);
      }
    });

    // 슬라이더 변경 시 UI 실시간 반영
    gapSlider.addEventListener("input", () => {
      gap = Number(gapSlider.value);
      gapValue.textContent = gap;
      applyConfig();
    });

    distortedToggle.addEventListener("change", () => {
      distorted = distortedToggle.checked;
      applyConfig();
    });

    // 순서 바꾸기 버튼
    orderToggle.addEventListener("change", () => {
      if (orderToggle.checked) {
        app.insertBefore(cam1, cam0);
        cameraOrder = "10";
      } else {
        app.insertBefore(cam0, cam1);
        cameraOrder = "01";
      }
      applyConfig();
    });

    fetchAndApplyConfig();

    // 모바일에서만 자동 숨김 기능
    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    let hideTimeout;

    if (isMobile) {
      function showControls() {
        controls.classList.remove("hidden");
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
          controls.classList.add("hidden");
        }, 3000);
      }

      window.addEventListener("load", showControls);
      document.addEventListener("touchstart", showControls);
    }
  </script>
</body>
</html>
